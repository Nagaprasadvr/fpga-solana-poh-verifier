# SHA-256: What the Hardware Actually Does

## Start With Why

You give SHA-256 any data. It gives back 256 bits that:
- Always the same for the same input
- Completely different if you change even 1 bit of input
- Impossible to reverse (can't find input from output)

The algorithm is just **bit shuffling + addition**, done 64 times.

---

## The Only Operations SHA-256 Uses

Before looking at the algorithm, understand the 5 operations. That's all there is.

### Operation 1: AND

```
  Input A:   1 0 1 1
  Input B:   1 1 0 1
  ─────────────────
  A AND B:   1 0 0 1
```

"Both must be 1 to get 1"

**Hardware:** 1 LUT4 per bit. A 4-input LUT can compute AND trivially — it's just one row in the truth table being 1.

### Operation 2: XOR

```
  Input A:   1 0 1 1
  Input B:   1 1 0 1
  ─────────────────
  A XOR B:   0 1 1 0
```

"Different = 1, Same = 0"

This is SHA-256's favorite operation. XOR is reversible (knowing output + one input → other input), spreads changes maximally, and is dirt cheap.

**Hardware:** 1 LUT4 per bit. A LUT4 can actually compute a 3-input XOR in a single lookup, which is exactly what Σ and σ functions need.

### Operation 3: NOT

```
  Input A:   1 0 1 1
  ─────────────────
  NOT A:     0 1 0 0
```

"Flip every bit"

**Hardware:** Often absorbed into other LUTs for free. A LUT computing `(NOT A) AND B` costs the same as `A AND B` — just a different truth table entry.

### Operation 4: Rotate Right (ROTR)

```
  ROTR by 2:
  Input:    [ 7 6 5 4 3 2 1 0 ]    (bit positions)
  Output:   [ 1 0 7 6 5 4 3 2 ]    (bits wrapped around)
```

The bottom bits wrap to the top. No bits are lost.

**Hardware: THIS IS JUST WIRES. Zero gates. Zero delay. Zero power.**

```
  In software:   result = (x >> 2) | (x << 30);  // costs CPU cycles
  
  In hardware:   wire [31:0] rotated;
                 assign rotated = {x[1:0], x[31:2]};  // free routing
```

The synthesizer literally connects output pin 31 to input pin 1, output pin 30 to input pin 0, output pin 29 to input pin 31, and so on. No logic is generated. It's a wiring diagram, not a circuit.

**This is the #1 reason FPGAs are good at hashing.**

### Operation 5: Addition (mod 2³²)

```
    01101011 10011010 11110000 01010101
  + 00110100 01100101 00001111 10101011
  ──────────────────────────────────────
    10100000 00000000 00000000 00000000
```

32-bit addition, throw away the carry-out (mod 2³²).

**Hardware:** This is the EXPENSIVE one. Addition requires a carry chain — bit 0's carry affects bit 1, which affects bit 2, which affects bit 3...

```
  Bit 0:  sum[0] = a[0] XOR b[0]
           carry[0] = a[0] AND b[0]

  Bit 1:  sum[1] = a[1] XOR b[1] XOR carry[0]
           carry[1] = (a[1] AND b[1]) OR (carry[0] AND (a[1] XOR b[1]))

  Bit 2:  sum[2] = a[2] XOR b[2] XOR carry[1]
           carry[2] = ...depends on carry[1]...
  
  ...carry ripples through all 32 bits...
```

FPGAs have dedicated **carry chain hardware** (fast physical connections between adjacent LUTs) that makes this much faster than building it from general LUTs. On Gowin FPGAs, each LUT4+carry slice handles one bit of addition.

**Cost: ~32 LUT+carry slices per 32-bit adder.**
**Delay: carry propagation through 32 stages** (this sets your max clock speed).

---

## Now: The Actual Algorithm, Gate by Gate

### Phase 1: Load the Message

Your input (e.g., a 256-bit hash for PoH) gets padded to 512 bits and split into sixteen 32-bit words:

```
W[0]  = input bits [0:31]      ← first 32 bits of your data
W[1]  = input bits [32:63]     ← next 32 bits
...
W[7]  = input bits [224:255]   ← last 32 bits of a 256-bit hash
W[8]  = 0x80000000             ← padding: a 1-bit then zeros
W[9]  = 0x00000000             ← more padding zeros
...
W[14] = 0x00000000             ← more zeros
W[15] = 0x00000100             ← message length in bits (256 = 0x100)
```

**Hardware:** 16 registers, each 32 bits wide. Total: 512 flip-flops. The FPGA loads your message into these registers. For PoH, W[8]-W[15] are always the same constants — you can hardwire them.

---

### Phase 2: Message Schedule (Expand 16 words → 64 words)

The first 16 words came from your input. Words 16 through 63 are generated from previous words:

```
W[16] = σ1(W[14]) + W[9] + σ0(W[1]) + W[0]
W[17] = σ1(W[15]) + W[10] + σ0(W[2]) + W[1]
...
W[i]  = σ1(W[i-2]) + W[i-7] + σ0(W[i-15]) + W[i-16]
```

**What σ0 does (small sigma 0):**

```
σ0(x) = ROTR(7,x) XOR ROTR(18,x) XOR SHR(3,x)
```

Let's trace it for x = 0xABCD1234:

```
x       = 10101011110011010001001000110100

ROTR 7  = 01101001010101111001101000100100   ← rotate right 7 (FREE)
ROTR 18 = 00010010001101001010101111001101   ← rotate right 18 (FREE)
SHR 3   = 00010101011110011010001001000110   ← shift right 3, top 3 bits = 0 (FREE)
          ─────────────────────────────────
XOR all  = 01101100100000101001001000101111   ← 32 LUTs (3-input XOR per bit)
```

**Hardware for σ0:**
- ROTR(7): 0 gates, just wire routing
- ROTR(18): 0 gates, just wire routing
- SHR(3): 0 gates, just wire routing (with 3 constant zeros at top)
- 3-way XOR: 32 LUT4s (each LUT4 can do a 3-input XOR in 1 lookup)
- **Total: 32 LUTs. That's it.**

**σ1 is identical structure, different rotation amounts:**
```
σ1(x) = ROTR(17,x) XOR ROTR(19,x) XOR SHR(10,x)
```
Also 32 LUTs.

**The full W[i] computation:**

```
         σ1(W[i-2])          W[i-7]         σ0(W[i-15])        W[i-16]
          32 bits             32 bits          32 bits           32 bits
            │                   │                │                 │
            └──────┬────────────┘                └────────┬────────┘
                   │                                      │
              ┌────▼─────┐                          ┌─────▼────┐
              │ 32-bit   │                          │ 32-bit   │
              │ adder #1 │                          │ adder #2 │
              │ (32 LUTs)│                          │ (32 LUTs)│
              └────┬─────┘                          └─────┬────┘
                   │                                      │
                   └──────────────┬───────────────────────┘
                                  │
                            ┌─────▼─────┐
                            │ 32-bit    │
                            │ adder #3  │
                            │ (32 LUTs) │
                            └─────┬─────┘
                                  │
                                W[i] (new 32-bit word)
```

**Total for one W step:** 32 (σ0) + 32 (σ1) + 96 (3 adders) = ~160 LUTs
**But** in an iterative design, this runs once per clock cycle and reuses the same hardware.

**Circular buffer trick:** Instead of storing all 64 W values, keep only 16 registers. Each cycle, shift them down and compute the new one:

```
Cycle 0:  W buffer holds W[0]..W[15]  (from input)
Cycle 1:  Compute W[16], shift: buffer now holds W[1]..W[16]
Cycle 2:  Compute W[17], shift: buffer now holds W[2]..W[17]
...
Cycle 48: Compute W[63], shift: buffer now holds W[48]..W[63]
```

**Hardware:** 16 × 32-bit registers = 512 flip-flops, connected as a shift register with the new W value entering at one end.

---

### Phase 3: Compression (64 rounds — THE MAIN EVENT)

This is where the hash actually happens. 8 working variables, each 32 bits:

```
a = 0x6a09e667  (H0)        Starts with the
b = 0xbb67ae85  (H1)        initial hash constants.
c = 0x3c6ef372  (H2)        For PoH round 2+,
d = 0xa54ff53a  (H3)        these start with the
e = 0x510e527f  (H4)        previous hash output.
f = 0x9b05688c  (H5)
g = 0x1f83d9ab  (H6)
h = 0x5be0cd19  (H7)
```

**Each of the 64 rounds does this:**

#### Step A: Compute Σ1(e) — "Big Sigma 1"

```
Σ1(e) = ROTR(6,e) XOR ROTR(11,e) XOR ROTR(25,e)
```

Example with e = 0x510e527f:

```
e       = 01010001000011100101001001111111
ROTR 6  = 11111101010001000011100101001001   ← FREE (wires)
ROTR 11 = 01001111111010100010000111001010   ← FREE (wires)
ROTR 25 = 00011100101001001111111010100010   ← FREE (wires)
          ────────────────────────────────
XOR all = 10100010110000110101011000110001   ← 32 LUTs
```

**Cost: 32 LUTs**

#### Step B: Compute Ch(e,f,g) — "Choose"

```
Ch(e,f,g) = (e AND f) XOR ((NOT e) AND g)
```

In plain English: "For each bit: if e=1, choose f's bit. If e=0, choose g's bit."

This is literally a **multiplexer.** Every FPGA LUT can do this trivially.

```
e bit:    1  0  1  1  0  0  1  0
f bit:    0  1  1  0  1  0  1  1
g bit:    1  1  0  1  0  1  0  0
          ─────────────────────
output:   0  1  1  0  0  1  1  0
          ↑  ↑  ↑  ↑  ↑  ↑  ↑  ↑
          f  g  f  f  g  g  f  g    ← picked based on e
```

**Cost: 32 LUTs** (one per bit, each LUT stores the 3-input truth table)

#### Step C: Compute temp1

```
temp1 = h + Σ1(e) + Ch(e,f,g) + K[i] + W[i]
```

Five 32-bit values added together. This is the critical path.

```
    h        Σ1(e)    Ch(e,f,g)    K[i]      W[i]
    │          │          │          │          │
    └────┬─────┘          └────┬─────┘          │
    ┌────▼─────┐          ┌────▼─────┐          │
    │ adder #1 │          │ adder #2 │          │
    └────┬─────┘          └────┬─────┘          │
         └────────┬────────────┘                │
             ┌────▼─────┐                       │
             │ adder #3 │                       │
             └────┬─────┘                       │
                  └──────────┬──────────────────┘
                        ┌────▼─────┐
                        │ adder #4 │
                        └────┬─────┘
                             │
                           temp1
```

**Cost: 4 × 32 = 128 LUTs** in the carry chains.
**Delay: 4 × (carry propagation through 32 bits)** — this is the SLOWEST part.

#### Step D: Compute Σ0(a) and Maj(a,b,c)

```
Σ0(a) = ROTR(2,a) XOR ROTR(13,a) XOR ROTR(22,a)
```
**Cost: 32 LUTs** (same structure as Σ1)

```
Maj(a,b,c) = (a AND b) XOR (a AND c) XOR (b AND c)
```

"For each bit: go with the majority. If 2 or 3 inputs are 1, output 1."

```
a bit:    1  0  1  1  0  0  1  0
b bit:    0  1  1  0  1  0  1  1
c bit:    1  1  0  1  0  1  0  0
          ─────────────────────
output:   1  1  1  1  0  0  1  0
          (2) (2) (2) (2) (1) (1) (2) (1)  ← count of 1s
```

A 3-input majority function fits in a single LUT4.
**Cost: 32 LUTs**

#### Step E: Compute temp2

```
temp2 = Σ0(a) + Maj(a,b,c)
```

**Cost: 32 LUTs** (one adder)

#### Step F: Update the working variables

```
h ← g           (just wires — connect g's register output to h's register input)
g ← f           (just wires)
f ← e           (just wires)
e ← d + temp1   (one 32-bit adder: 32 LUTs)
d ← c           (just wires)
c ← b           (just wires)
b ← a           (just wires)
a ← temp1 + temp2  (one 32-bit adder: 32 LUTs)
```

**THIS IS CRITICAL TO UNDERSTAND:** The shift h←g←f←e←d←c←b←a is NOT a copy operation in hardware. It's how the registers are wired:

```
    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐    ┌───┐
    │ a │───→│ b │───→│ c │───→│ d │    │ e │───→│ f │───→│ g │───→│ h │
    └─▲─┘    └───┘    └───┘    └─│─┘    └─▲─┘    └───┘    └───┘    └───┘
      │                          │         │
      │                          │ +temp1  │
      │                          └────▶ adder ──→ new_e
      │
    temp1 + temp2 ──→ new_a
```

On each clock edge, all 8 registers update simultaneously. This is one "round."

---

### Phase 4: Final Addition

After round 63 completes:

```
H0_new = H0_initial + a      (32-bit add)
H1_new = H1_initial + b
H2_new = H2_initial + c
H3_new = H3_initial + d
H4_new = H4_initial + e
H5_new = H5_initial + f
H6_new = H6_initial + g
H7_new = H7_initial + h
```

**Output = H0 || H1 || H2 || H3 || H4 || H5 || H6 || H7 = your 256-bit hash.**

For PoH, this output becomes the input to the next SHA-256 call.

---

## Complete Timing (Iterative Design)

```
Clock cycle 0:     Load message into W[0]-W[15], init a-h
Clock cycles 1-16: Rounds 0-15  (W comes directly from buffer)
Clock cycles 17-64: Rounds 16-63 (W computed on-the-fly)
Clock cycle 65:    Final addition, output hash
                   ─────────────
                   ~66 total cycles per hash
```

At 100 MHz: one hash every 660 nanoseconds = **~1.5 million hashes/second per core.**

---

## What One SHA-256 Core Looks Like as Verilog Modules

```
sha256_core
├── sha256_w_schedule     ← 16-register circular buffer + σ0, σ1, adders
├── sha256_round          ← Σ0, Σ1, Ch, Maj, temp1, temp2, adders
├── sha256_k_rom          ← 64-entry constant table (case statement)
└── sha256_control        ← FSM: idle → load → round(×64) → finalize → done
```

Each module maps directly to a section in this document.
